---
--- Generated by Luanalysis
--- Created by rodelbianco.
--- DateTime: 3/31/23 8:17 AM
---

local lpeg = require('lpeg')

local helpers = require('./utils/helpers')
require('./utils/functions')
local parser = require('./utils/parser')
local compiler = require('./utils/compiler')
local runtime = require('./utils/runtime')

local should_show_parser_result,should_show_compiler_result = ...
print('should_show_parser_result -> '..helpers.as_string(should_show_parser_result=='1'))
print('should_show_compiler_result -> '..helpers.as_string(should_show_compiler_result=='1'))
print()

function testStack(testCase, operator, value, shouldRun)
    shouldRun = shouldRun == nil or shouldRun == true
    result = nil
    str_value = 'value (\'' .. value .. '\')'
    str_value = string.format('[%-20s]', str_value)

    --print()
    --print(string.format('BEG>[%20s]: ', testCase) .. str_value)

    parser_result = parser.parse(operator, value)

    if should_show_parser_result == '1' then
        result = helpers.as_string(parser_result)
        print('parser -> ' .. result)
        print()
    end

    if parser_result and helpers.istable(parser_result) then
        compiler_result = compiler.compile(parser_result)
        if should_show_parser_result == '1' then
            result = helpers.as_string(compiler_result)
            print('compiler -> ' .. result)
            print()
        end

        if shouldRun and compiler_result and helpers.istable(compiler_result) then
            local stack = {}
            local global_mem = { }
            local mem = { }
            result = runtime.run(compiler_result, global_mem, mem, stack)
            result = result
            runtime_stack = helpers.as_string(stack)
            runtime_mem = helpers.as_string(mem)
            --print('runtime stack -> ' .. runtime_stack)
            --print('runtime mem -> ' .. runtime_mem)
            --print('runtime result -> ' .. helpers.as_string(result))
        end
    end

    print(string.format('[%20s]: ', testCase) .. str_value .. ' -> ' .. (helpers.as_string(result) or 'nil'))
    print()

end

local P = lpeg.P
local S = lpeg.S
local R = lpeg.R
local C = lpeg.C
local Ct = lpeg.Ct
local Cp = lpeg.Cp
local Cg = lpeg.Cg
local Cc = lpeg.Cc
local Cmt = lpeg.Cmt
local V = lpeg.V
local escape = P('%')

function token(token)
    return parser.add_token(token)
end

function optional_token(token)
    return parser.add_token(P(token) ^ -1)
end

function reserved_word(reserved_word)
    return parser.add_reserved_word(reserved_word)
end

lhs = V 'lhs'
function_call = V 'function_call'
primary = V 'primary'
factor = V 'factor'
term = V 'term'
expression = V 'expression'
negation_expression = V 'negation_expression'
logic_expression = V 'logic_expression'
comparison_expression = V 'comparison_expression'
new_expression = V 'new_expression'
expression_patterns = V 'expression_patterns'
parenthesis_expression = V 'parenthesis_expression'
unary = V 'unary'
statement = V 'statement'
statement_list = V 'statement_list'
block = V 'block'
block_list = V 'block_list'
else_patterns = V 'else_patterns'
function_declaration = V 'function_declaration'
function_call = V 'function_call'
function_call_pattern = V 'function_call_pattern'
id = V 'id'
space_patterns = V 'space_patterns'
line_ending = V 'line_ending'
params = V 'params'
args = V 'args'

local newline = P('\n') * space_patterns
local space = S('\t ')

local line_comment = token '#' * (P(1) - newline) ^ 0 * space_patterns
local block_comment = token '#{' * (P(1) - token '}#') ^ 0 * token '}#'
local comment_patterns = (block_comment + line_comment) * P(parser.set_max_space_position) * newline ^ 0
parser.space_patterns = space_patterns

local alpha = R('az', 'AZ')
local digit = R('09')
local alphanum = alpha + digit
local valid_id_caracters = alphanum + S('_')
parser.valid_id_caracters = valid_id_caracters

local boolean = (reserved_word('true') + reserved_word('false'))
        / helpers.toboolean / boolean_node * space_patterns
local integer = digit ^ 1
local decimal = digit ^ 0 * P('.') * digit ^ 1
local hexadecimal = R('09', 'af', 'AF')
local scientic_notation = digit ^ 1 * P('.') ^ -1 * digit ^ 0 * S('eE') * S('+-') ^ -1 * digit ^ 1
local hex_pattern = escape * S('xX') * C(hexadecimal ^ 1) * Cc(16)
local assign_operator = C(S('=')) * space_patterns
local op = token '('
local cp = token ')'
local ob = token '{'
local cb = token '}'
local semicolon = token ';' * space_patterns
local statement_separator = semicolon * newline ^ 1 + semicolon + newline ^ 1

local a_operator = C(S('+-')) * space_patterns / binop_node
local m_operator = C(S('*/%')) * space_patterns / binop_node
local factor_operator = C(S('^')) * space_patterns / binop_node

local l_operator = (reserved_word '&&' + reserved_word '||' + reserved_word 'and' + reserved_word 'or') / logic_node

local c_operator = C(P('<=') + P('>=') + P('==') + P('!=') + P('>') + P('<')) * space_patterns / comparison_node
local negation_operator = token('-')
local boolean_negation_operator = token('!')
local numeral = (scientic_notation + hex_pattern + decimal + integer) / tonumber / numeric_node * space_patterns

local variable = id / node('variable', 'id')
local indexed_variable = Ct(variable * (token '[' * expression_patterns * token ']') ^ 0)
        / fold_indexed

local local_assignment_statement = reserved_word 'local' * lhs * (assign_operator * expression_patterns)^-1
local default_assignment_statement = Cc('default') * lhs * assign_operator * expression_patterns
local assignment_statement = (local_assignment_statement + default_assignment_statement) / assignment_node

local return_statement = reserved_word 'return' ^ -1 * expression_patterns / return_node
local print_statement = reserved_word 'print' * expression_patterns / print_node

local statement_patterns = (assignment_statement
        + function_call_pattern * Cc(true) / node('function_call', 'name', 'args', 'is_statement')
        + return_statement
        + print_statement
        + block
        + reserved_word 'if' * expression_patterns * block * else_patterns
        / if_node
        + reserved_word 'unless' * expression_patterns * block * else_patterns
        / unless_node
        + reserved_word 'while' * expression_patterns * block
        / while_node
)

numeric_grammar = P { 'entrypoint',
                      entrypoint = Ct((space + function_declaration + statement) ^ 1),
                      lhs = indexed_variable,
                      primary = function_call + boolean + numeral + (op * negation_expression * cp) + lhs,
                      unary = primary + negation_operator * primary / fold_unary_neg_node,
                      factor = Ct(unary * (factor_operator * unary) ^ 0) / fold_binop_node,
                      term = Ct(factor * (m_operator * factor) ^ 0) / fold_binop_node,
                      expression = Ct(term * (a_operator * term) ^ 0) ^ 1 / fold_binop_node * space_patterns,
                      negation_expression = boolean_negation_operator * expression / fold_boolean_neg_node
                              + expression,
                      comparison_expression = Ct(negation_expression * c_operator * negation_expression)
                              / fold_binop_node,
                      logic_expression = Ct((comparison_expression + negation_expression)
                              * (l_operator * logic_expression) ^ -1) / fold_binop_node,
                      new_expression = reserved_word 'new' * Ct((token '[' * expression_patterns * token ']') ^ 1)
                              / fold_new_arr_node,
                      expression_patterns = logic_expression + new_expression,
                      statement = space_patterns * (statement_patterns + expression_patterns
                              + comment_patterns / empty_node) * line_ending ^ -1,
                      statement_list = statement * statement_list ^ -1 / sequence_node,
                      block = token '{' * newline ^ 0 * statement_list ^ 1 * token '}' * space_patterns
                              / node('block', 'block'),
                      space_patterns = space ^ 0 * P(parser.set_max_space_position),
                      else_patterns = reserved_word 'elseif' * expression_patterns * block * else_patterns
                              / if_node --node('if', 'condition', 'if_block', 'else_block')
                              + (reserved_word 'else' * block) ^ -1,
                      id = Cmt(C(S('@$!') ^ -1 * alpha ^ 1 * valid_id_caracters ^ 0), parser.is_not_reserved)
                              * space_patterns,
                      line_ending = statement_separator + semicolon ^ -1 * comment_patterns, -- subtlety
                      function_declaration = reserved_word 'function' * id * token '(' * params * token ')' * block ^ -1
                              * line_ending ^ -1 / function_declaration_node,
                      function_call_pattern = id * token '(' * args * token ')',
                      params = Ct((id * (token ',' * id - (token ',' * id * assign_operator * expression_patterns)) ^ 0
                               * Ct(token ',' * id * assign_operator * expression_patterns) ^-1) ^ -1),
                      function_call = function_call_pattern / node('function_call', 'name', 'args'),
                      args = Ct((expression_patterns * (token ',' * expression_patterns) ^ 0) ^ -1),
} * -1



testStack('assign 1', numeric_grammar, 'a=1')
testStack('expression 2', numeric_grammar, '1')
testStack('expression 3', numeric_grammar, '1+1')
testStack('expression 6', numeric_grammar, '{a=1;return 1+a}')
testStack('expression 8', numeric_grammar, '2 + 1')
testStack('expression 9', numeric_grammar, '400 +1')
testStack('expression 10', numeric_grammar, '5+1 ')
testStack('expression 11', numeric_grammar, '6+2+3 ')
testStack('expression 12', numeric_grammar, '7-2+3 ')
testStack('expression 13', numeric_grammar, ' 8 + 1 + 1 ')
testStack('expression 14', numeric_grammar, '12+13+25 ')
testStack('expression 15', numeric_grammar, '  12  + 13  +  25  ')
testStack('expression 16', numeric_grammar, '  2  + 14  *  2  ')
testStack('expression 17', numeric_grammar, '  2  % 2  ')
testStack('expression 18', numeric_grammar, '  3  % 2  ')
testStack('expression 19', numeric_grammar, '  2  ^ 2  ')
testStack('expression 20', numeric_grammar, '  3  ^ 3  ')
testStack('expression 21', numeric_grammar, '  4  ^ 4  ')
testStack('expression 22', numeric_grammar, '2 * ( 2 + 4 ) ^ 2 * 10 ')
testStack('expression 23', numeric_grammar, '-2 * ( 2 + 4 ) ^ 2 * -10 ')
testStack('expression 24', numeric_grammar, '- 2 * ( 2 + 4 ) ^ 2 *  10 ')
testStack('expression 25', numeric_grammar, '2 * (2 + 4 ) ^ 2 * - 10 ')
testStack('expression 26', numeric_grammar, '2 * (-2 + -4 ) ^ 2 * 10 ')
testStack('expression 27', numeric_grammar, '2 * (2 + -4 ) ^ 2 * 10 ')
testStack('expression 28', numeric_grammar, '2 * (-2 + 4 ) ^ 2 * 10 ')
testStack('expression 29', numeric_grammar, '2 * (- 2 + 4 ) ^ 2 * 10 ')
testStack('expression 30', numeric_grammar, '2 * (2 + - 4 ) ^ 2 * 10 ')
----------------------------------------------------------------------------------------------------------------
testStack('hex 1', numeric_grammar, '%x1')
testStack('hex 2', numeric_grammar, '%x10')
testStack('hex 3', numeric_grammar, '%x1F')
testStack('hex 4', numeric_grammar, '%Xa')
testStack('hex 5', numeric_grammar, '%XA1')
testStack('hex 6', numeric_grammar, '%xAA')
testStack('expression 31', numeric_grammar, '  -3  % 2  ')
testStack('expression 32', numeric_grammar, '  2  ^ -2  ')
testStack('expression 33', numeric_grammar, '  -2  ^ 2  ')
testStack('expression 34', numeric_grammar, '  12  + 13  +  25  ')
testStack('expression 35', numeric_grammar, '  12  + - 13  +  25  ')
testStack('expression 36', numeric_grammar, '  12  - - 13  - - 25  ')
testStack('expression 37', numeric_grammar, ' - 2 - - 14  *  2  ')
testStack('comparison 1', numeric_grammar, ' 2 == 2  ')
testStack('comparison 2', numeric_grammar, ' 2 != 2  ')
testStack('comparison 3', numeric_grammar, ' 2 == 3  ')
testStack('comparison 4', numeric_grammar, ' 2 <= 3  ')
testStack('comparison 5', numeric_grammar, ' 3 <= 3  ')
testStack('comparison 6', numeric_grammar, ' 4 <= 3  ')
testStack('comparison 7', numeric_grammar, ' 2 >= 3  ')
testStack('comparison 8', numeric_grammar, ' 2 < 3  ')
testStack('comparison 9', numeric_grammar, ' 2 > 3  ')
testStack('comparison 10', numeric_grammar, ' 2 != 3  ')
testStack('comparison 11', numeric_grammar, ' (2 ^2) ^ 2 != (3 ^ 2)  ')
testStack('comparison 12', numeric_grammar, ' (2 ^2) < (3 ^ 2)  ')
testStack('comparison 13', numeric_grammar, ' (2 ^2) > (3 ^ 2)  ')
testStack('comparison 14', numeric_grammar, ' (2 ^2) == (2 ^ 2)  ')
testStack('float 1', numeric_grammar, '  1 + .7  ')
testStack('float 2', numeric_grammar, '  1 - .7  ')
testStack('float 3', numeric_grammar, '  1 * .7  ')
testStack('float 4', numeric_grammar, '  1 / .7  ')
testStack('float 5', numeric_grammar, '  1 ^ .7  ')
testStack('float 6', numeric_grammar, '  1 % .7  ')
testStack('float 7', numeric_grammar, '  12  + 13  -  25 - .7 ')
testStack('float 8', numeric_grammar, '  12.5  + 13.2  -  25 + .7  ')
testStack('float 9', numeric_grammar, '  12.5  + 13.2 ')
testStack('float 10', numeric_grammar, '  12.5  + 13.2  -  25 ')
testStack('float 11', numeric_grammar, '  12.5  + 13.2  -  25 - .7  ')
testStack('scientific 1', numeric_grammar, '  0.5E-3  ')
testStack('scientific 2', numeric_grammar, '  123e12  ')
testStack('scientific 3', numeric_grammar, '  1.000000000000000E+00  ')
testStack('scientific 4', numeric_grammar, '  2.000000000000000E+02  ')
testStack('scientific 5', numeric_grammar, '-1.000000000000000E+05')
testStack('scientific 6', numeric_grammar, '27 + - 1.000000000000000e+05')
testStack('scientific 7', numeric_grammar, '  123e12  + 13.2  -  25 - .7  ')
--------------------------------------------------------------------------------------------------------------
testStack('statement block 1', numeric_grammar, '{a=2}')
testStack('statement block 2', numeric_grammar, '{a=2;b=5;c=3+a+b;result=a+b+c;}')
testStack('statement block 3', numeric_grammar, '{a=2;b=5;a+b}')
testStack('statement block 4', numeric_grammar, '{a=2+3+5;a+3;}')
testStack('statement block 5', numeric_grammar, '{return 2}')
testStack('statement block 6', numeric_grammar, '{$a_1=1;return $a_1 + 2}')
testStack('statement block 9', numeric_grammar, '{c=1;b=1+1+3;a=1;a+b+1;a=b+a+a;return a;}')
testStack('statement block 10', numeric_grammar, '{b=1+1+3;a=1;a=b+a+a;print  a; a}')
testStack('statement block 11', numeric_grammar, '{$a_1=0;return $a_1 + 2}')
testStack('reserved words 1', numeric_grammar, '{returnx=1;return returnx + 2}')
testStack('reserved words 1', numeric_grammar, '{returnx=1;return returnx + 2}')
testStack('negated boolean 1', numeric_grammar, '!1')
testStack('negated boolean 2', numeric_grammar, '!0')
testStack('negated boolean 3', numeric_grammar, '!true')
testStack('negated boolean 4', numeric_grammar, '!false')
testStack('if 1', numeric_grammar, '{x=1; if x==1{return x + 2}; x;}')
testStack('if 2', numeric_grammar, '{x=2; if x==1{return x + 2}; x;}')
testStack('if 3', numeric_grammar, '{x=2; if x==1{return x + 2}else{return 5;}; x;}')
testStack('if 4', numeric_grammar, '{x=1; if x==1{return x + 2} elseif x<3 {return 10;}else{return 5;}; x;}')
testStack('if 5', numeric_grammar, '{x=2; if x==1{return x + 2} elseif x<3 {return 10;}else{return 5;}; x;}')
testStack('if 6', numeric_grammar, '{x=3; if x==1{return x + 2} elseif x<3 {return 10;}else{return 5;}; x;}')
testStack('if 7', numeric_grammar, '{x=3; if x==1{return x + 2} elseif x<3 {return 10;} elseif x==3 {return 33;}else{return 5;}; x;}')
testStack('if 8', numeric_grammar, '{x=5; if x==1{return x + 2} elseif x<3 {return 10;} elseif x==3 {return 33;}else{return 5;}; x;}')
--------------------------------------------------------------------------------------------------------------
testStack('logic expression 1', numeric_grammar, ' true && false')
testStack('logic expression 2', numeric_grammar, ' false && true')
testStack('logic expression 3', numeric_grammar, ' true && true')
testStack('logic expression 4', numeric_grammar, ' false && false')
testStack('logic expression 5', numeric_grammar, ' true || false')
testStack('logic expression 6', numeric_grammar, ' false || true')
testStack('logic expression 7', numeric_grammar, ' true || true')
testStack('logic expression 7', numeric_grammar, ' false || false')
testStack('logic expression 8', numeric_grammar, ' true and false')
testStack('logic expression 9', numeric_grammar, ' false and true')
testStack('logic expression 10', numeric_grammar, ' true and true')
testStack('logic expression 11', numeric_grammar, ' false and false')
testStack('logic expression 12', numeric_grammar, ' true or false')
testStack('logic expression 13', numeric_grammar, ' false or true')
testStack('logic expression 14', numeric_grammar, ' true or true')
testStack('logic expression 15', numeric_grammar, ' false or false')
testStack('logic expression 16', numeric_grammar, '2==2 and 1==1')
testStack('logic expression 17', numeric_grammar, '2!=2 and 1==1')
testStack('logic expression 18', numeric_grammar, '2==2 and 1!=1')
testStack('logic expression 19', numeric_grammar, '2!=2 and 1!=1')
testStack('logic expression 20', numeric_grammar, '2==2 or 1==1')
testStack('logic expression 21', numeric_grammar, '2!=2 or 1==1')
testStack('logic expression 22', numeric_grammar, '2==2 or 1!=1')
testStack('logic expression 23', numeric_grammar, '2!=2 or 1!=1')
--------------------------------------------------------------------------------------------------------------
testStack('line comment 1', numeric_grammar, [[1 #+12]])
testStack('line comment 2', numeric_grammar, '#1 +\n12')
testStack('block comment 1', numeric_grammar, '#{1 + 12}#1+1+3')
------------------------------------------------------------------------------------------------------------
testStack('while 1', numeric_grammar, '{ac=1;n=6; while n>0 {ac = ac * n; n = n - 1}; return ac;}', true)
testStack('while 2', numeric_grammar, '{n=6; while n>0 {if n<5 and n%2==0{print n;return n}; n = n - 1;};}')
testStack('while 3', numeric_grammar, '{n=6; while n>0 {print n; n = n - 1;};}')
------------------------------------------------------------------------------------------------------------
testStack('arrays 1', numeric_grammar, 'n=new[1]')
testStack('arrays 2', numeric_grammar, '{n=new[10]; return n;}')
testStack('arrays 3', numeric_grammar, '{n=new[10]; return n[1];}')
testStack('arrays 4', numeric_grammar, '{n=new[10]; n[1]=123;}')
testStack('arrays 5', numeric_grammar, '{n=new[10]; n[1]=123;return n[1];}')
testStack('arrays 6', numeric_grammar, '{n=new[10]; n[1]=123;n[2]=123;n[3]=n[1]+n[2];return n[3];}')
testStack('arrays 7', numeric_grammar, '{n=new[10]; return n[10];}')
testStack('print arrays 1', numeric_grammar, '{n=new[10]; n[1]=123;print  n; return n[1]}')
testStack('print arrays 2', numeric_grammar, '{n=new[10]; n[1]=new [10];n[2]=new [10];n[1][1]=123;n[2][1]=123;n[1][2]=n[1][1]+n[2][1];print  n; return n[1][2]}')
--------------------------------------------------------------------------------------------------------------
testStack('multidimentional arrays 1', numeric_grammar, '{n=new[10][1]; n[1][1]=123;return n[1][1];}')
testStack('multidimentional arrays 2', numeric_grammar, '{n=new[10][1]; n[1][1]=123;n[2][1]=123;n[3][1]=n[1][1]+n[2][1];return n[3][1];}')
testStack('multidimentional arrays 3', numeric_grammar, '{n=new[10][5][3]; n[1][1][2]=123;return n[1][1][2];}')
testStack('multidimentional arrays 4', numeric_grammar, '{n=new[10][5][3]; n[1][1][2]=123;return n[1][1][1];}')
testStack('multidimentional arrays 5', numeric_grammar, '{n=new[10][5][3]; n[1][1][2]=123;n[1][1][3]=123;n[1][1][1]=123;n[2][1][1]=n[1][1][1]+n[1][1][2]+n[1][1][3];return n[1][1][1];}')
testStack('multidimentional arrays 6', numeric_grammar, '{n=new[10][5][3]; n[1][1][2]=123;n[1][1][3]=123;n[1][1][1]=123;n[2][2][2]=n[1][1][1]+n[1][1][2]+n[1][1][3];print n;}')
testStack('multidimentional arrays 7', numeric_grammar, '{n=new[10][5][3]; n[1][1][1]=123;n[10][5][3]=999;n[2][2][3]=n[1][1][1]+1;print n;}')
----------------------------------------------------------------------------------------------------------------
testStack('functions 1', numeric_grammar, [[function main() {
n=1
return n;
}]])
--
testStack('functions 2', numeric_grammar, [[function calc() {n=1+2+3;print n;return n}
function main() {
n = 1
#{
n=1
return n + calc()
}#

res1 = calc() + n
res2 = n + calc()

print res1
return res1 == res2
}]])

testStack('functions 3', numeric_grammar, [[function calc() {n=1+2+3;print n;return n}
function main() {
calc()
return 1
}]])

testStack('blocks 1', numeric_grammar, '{n=5{n=10} return n}')

testStack('blocks 2', numeric_grammar, [[{
{



n=10;

return n;

}
return 1
}]])

testStack('blocks 3', numeric_grammar, [[
function calc() {n=1+2+3;print n;
# calc()
return n}

function main() {n=5{n=10} return calc()}
]])

testStack('blocks 4', numeric_grammar, [[
function calc() {n=1+2+3;
print n;
return n}

function main() {n=5             # { print  1#}
#{ print  1#}
# print 2

return calc() # print 2
}
]])

testStack('blocks 5', numeric_grammar, [[
function calc() {
n=1+2+3
#calc()
return n
}

function main() {
n=11;
#oi
{a=1}
#{ oi }#
#{
oi
}#

n = 1

#foi

print calc()
n=2;
return n
}
]])

testStack('blocks 6', numeric_grammar, [[
function calc() {
n=1+2+3;
print n
#{ calc()#};
#calc()
return n
}

function main() {
# calc()
n=5;
{n=10}
return n+calc()}
]])

testStack('blocks 7', numeric_grammar, [[
function calc() {n=3;n=4;print n;print n;return n}
function main() {
#calc()
n=5;
return n+calc()}
]])


testStack('blocks 8', numeric_grammar, [[
function main() {
#{


print n


}#
#print n;
n=3;

print n;
print n;
#print n;
{n=10;x=5}
#print n;
x=11
print n;
print x;
return n;

}
]])

testStack('function: var with same name as function', numeric_grammar, [[
function calc() {n=3;n=4;{n=n+10;y=11;print n;print n;}print n;return @n+1}
function main() {
#calc()
@n=1
print @n
print calc()
#calc=5;
return n+calc()}
]])

testStack('function: forward function 1', numeric_grammar, [[
    function xpto (n);

    function xpto (n) {
        print n
        if n > 0 {
            n = n - 1
            return xpto (n)
        }
        return 0
    }

    function main () {
        x = xpto(10)
        return x
    }
]])

testStack('function: forward function 2', numeric_grammar, [[
    function odd (n);
    function even (n);
    function xpto (n);

    function even (n) {
        if n == 0 {
            return 1;
        } else {
            return odd (n-1)
        }
    }

    function odd (n) {
        if n == 0 {
            return 0;
        } else {
            return even (n-1)
        }

    }

    function xpto (n) {
        print n
        if n > 0 {
            n = n - 1
            return xpto (n)
        }
        return 0

    }

    function main () {
        n = 1;
        print  even(n)
        print  odd(n)
        m = 6

        print  even(m)
        print  odd(m)
    }
]])

testStack('function: name parameters', numeric_grammar, [[
function test(n, m, y=3){print n; print m; print y}
    function main () {
        m = 5
        n = 1
        {local n=2}
        test(m, n )
        #print  even(m)
        #print  odd(m)
    }
]])

testStack('unless 1', numeric_grammar, [[
    function main () {
        m = 5
        n = 5

        unless m == n {
        print 999
        return 999
        }else {
        print 1001
        return 1001
        }
    }
]])

testStack('unless 2', numeric_grammar, [[
    function main () {
        m = 5
        n = 1

        unless m == n {
        print 999
        return 999
        }else {
        print 1001
        return 1001
        }
    }
]])

