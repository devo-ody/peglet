---
--- Generated by Luanalysis
--- Created by rodelbianco.
--- DateTime: 4/1/23 1:10 PM
---
local lpeg = require('lpeg')
local helpers = require('./utils/helpers')

local parser = { _version = "0.0.1",
                 max_space_position = 0 }

local vars = {}

parser.valid_id_caracters = lpeg.P(false)
parser.space_patterns = lpeg.P(true)
parser.reserved_words_list = {}
parser.excluded_patterns = lpeg.P(false)
parser.reserved_words = lpeg.P(false)

function parser.add_reserved_word(reserved_word)
    parser.reserved_words_list[reserved_word] = true

    parser.excluded_patterns = parser.excluded_patterns + reserved_word
    parser.reserved_words = parser.excluded_patterns * -parser.valid_id_caracters

    return lpeg.C(reserved_word) * parser.space_patterns
end

function parser.add_token(token)
    return token * parser.space_patterns
end

function parser.set_max_space_position(_, position)
    parser.max_space_position = math.max(parser.max_space_position, position)
    return true
end

function parser.watch(msg)
    return lpeg.P(function(_, position)
        print(msg .. '->' .. _)
        return true
    end)
end

function parser.is_not_reserved(subject, position, match)
    if not parser.reserved_words:match(match) then
        return true, match
    else
        return false
    end
end

function transform_binop(op_param)
    op = ''
    if op_param == '+' then
        op = 'add'
    elseif op_param == '-' then
        op = 'sub'
    elseif op_param == '*' then
        op = 'mul'
    elseif op_param == '/' then
        op = 'div'
    elseif op_param == '^' then
        op = 'pow'
    elseif op_param == '%' then
        op = 'rem'
    elseif op_param:gsub("%s+", "") == '' then
        error('operator parameter is empty')
    else
        error('unknown operator -> [' .. op_param .. ']')
    end
    return op
end

function transform_comparison(op_param)
    op = ''
    if op_param == '<=' then
        op = 'lte'
    elseif op_param == '>=' then
        op = 'gte'
    elseif op_param == '==' then
        op = 'eq'
    elseif op_param == '!=' then
        op = 'dif'
    elseif op_param == '<' then
        op = 'lt'
    elseif op_param == '>' then
        op = 'gt'
    elseif op_param:gsub("%s+", "") == '' then
        error('operator parameter is empty')
    else
        error('unknown operator -> [' .. op_param .. ']')
    end
    return op
end

function transform_logic(op_param)
    op = ''
    if op_param == 'and' or op_param == 'or' then
        op = op_param
    elseif op_param == '&&' then
        op = 'and'
    elseif op_param == '||' then
        op = 'or'
    elseif op_param:gsub("%s+", "") == '' then
        error('operator parameter is empty')
    else
        error('unknown operator -> [' .. op_param .. ']')
    end
    return op
end

expression_tags = helpers.table_as_set({ 'default', 'number', 'boolean', 'variable', 'indexed_var',
                                         'new_arr', 'new_subarr', 'binop', 'logic', 'comp', 'unary',
                                         'boolean_neg', 'function_call' })

statement_tags = helpers.table_as_set({ 'assign', 'local', 'if', 'unless', 'while', 'err', 'return', 'empty',
                                        'prt', 'function_declaration', 'block', 'function_call' })

node_tags = helpers.join_new_table(expression_tags, statement_tags)

function node (...)
    local param_list, param_count = helpers.table_pack(...)
    local tag = param_list[1]

    if not node_tags[tag] then
        error('Parsing Error: Syntax tag: (' .. tag .. ') not recognized')
    end

    return function(...)
        local values = helpers.table_pack(...)

        local node = { tag = tag }

        for i = 2, param_count, 1 do
            node[param_list[i]] = values[i - 1]
        end

        if statement_tags[tag] then
            node['is_statement'] = true
        end

        return node
    end
end

function numeric_node(value)
    return node('number', 'value')(value)
end

function boolean_node(value)
    return node('boolean', 'value')(value)
end

function binop_node(value)
    return node('binop', 'value')(transform_binop(value))
end

function logic_node(value)
    return node('logic', 'value', 'type')(transform_logic(value), 'boolean')
end

function comparison_node(value)
    return node('comp', 'value', 'type')(transform_comparison(value), 'boolean')
end

function unless_node(...)
    local unless_pack = helpers.table_pack(...)
    local condition = unless_pack[2]
    local unless_block = unless_pack[3]
    local else_block
    if unless_pack[4] == 'else' then
        else_block = unless_pack[5]
    else
        else_block = unless_pack[4]
    end
    return node('unless', 'condition', 'unless_block', 'else_block')(condition, unless_block, else_block)
end

function if_node(...)
    local if_pack = helpers.table_pack(...)
    local condition = if_pack[2]
    local if_block = if_pack[3]
    local else_block
    if if_pack[4] == 'else' then
        else_block = if_pack[5]
    else
        else_block = if_pack[4]
    end
    return node('if', 'condition', 'if_block', 'else_block')(condition, if_block, else_block)
end

function while_node(...)
    local while_pack = helpers.table_pack(...)
    local condition = while_pack[2]
    local while_block = while_pack[3]
    return node('while', 'condition', 'while_block')(condition, while_block)
end

function function_declaration_node(...)
    local function_declaration_pack = helpers.table_pack(...)
    local name = function_declaration_pack[2]
    local params = function_declaration_pack[3]
    local function_block = function_declaration_pack[4]
    return node('function_declaration', 'name', 'params', 'function_block')(name, params, function_block)
end

function indexed_variable_node(...)
    local indexed_variable_pack = helpers.table_pack(...)
    local array = indexed_variable_pack[2]
    local index = indexed_variable_pack[3]
    return node('indexed_var', 'array', 'index')(array, index)
end

function variable_node(id)
    if not vars[id] then
        return node('err', 'value', 'expression')('001', 'Variable (' .. id .. ') not defined')
    else
        return node('variable', 'id')(id)
    end
end

function assignment_node(...)
    local assignment_pack = helpers.table_pack(...)
    local variant = assignment_pack[1]
    local variable = assignment_pack[2]
    local op = assignment_pack[3]
    local expression = assignment_pack[4]

    variable.variant = variant
    expression = expression or numeric_node(0)
    vars[variable] = expression
    return node('assign', 'variable', 'expression')(variable, expression)
end

function return_node(statement, expression)
    if not expression then
        expression = statement
    end
    return node('return', 'expression')(expression)
end

function print_node(statement, expression)
    return node('prt', 'expression')(expression)
end

function empty_node()
    return node('empty')()
end

function default_node()
    return node('default', 'type')(nil)
end

function sequence_node(statement_1, statement_2)

    if not statement_1 or statement_1 == '' then
        statement_1 = empty_node()
    end

    if not statement_2 or statement_2 == '' then
        statement_2 = empty_node()
    end
    -- TODO: colocar a definição de statement aqui
    return { tag = 'seq',
             is_statement = true,
             statement_1 = statement_1,
             statement_2 = statement_2
    }
end

function fold_boolean_neg_node(expression_lst, param)
    local tree = expression_lst
    return node('boolean_neg', 'op', 'exp1')('bneg', tree)
end

function fold_unary_neg_node(expression_lst)
    local tree = expression_lst
    return node('unary', 'op', 'exp1')('uneg', tree)
end

function fold_indexed(array_lst)
    local tree = array_lst[1]
    for i = 2, #array_lst do
        index = array_lst[i]
        tree = node('indexed_var', 'array', 'index', 'type')(tree, index, 'array')
    end


    return tree
end

function fold_new_arr_node(...)
    fold_new_arr_node_pack = helpers.table_pack(...)
    foldable_array = fold_new_arr_node_pack[2]
    local tree = node('new_arr', 'size', 'type', 'seed_expression')(foldable_array[#foldable_array], 'array', default_node())
    for i = #foldable_array - 1, 1, -1 do
        size = foldable_array[i]
        tree = node('new_arr', 'size', 'type', 'seed_expression')(size, 'array', tree)
    end

    return tree
end

function new_arr_node(...)
    new_pack = helpers.table_pack(...)
    size = new_pack[2]
    return node('new_arr', 'size')(size)
end

---@return "number" | "string" | "boolean"
function set_expression_type(exp1, exp2, op)
    return_type = exp1.type or exp2.type

    if (op.type == 'boolean') then
        return_type = 'boolean'
    end
    return return_type
end

function fold_binop_node(expression_lst)
    local tree = expression_lst[1]
    for i = 2, #expression_lst, 2 do
        exp1 = tree
        exp2 = expression_lst[i + 1]
        op = expression_lst[i]
        tree = node(expression_lst[i].tag, 'op', 'exp1', 'exp2', 'type')(op.value, exp1, exp2, set_expression_type(exp1, exp2, op))
        --print('INT>tree -> ('..helpers.as_string(tree)..')')
    end

    return tree
end

local function syntaxError (input, max_space)
    position = math.max(max_space + 1, 0)
    pre_error_content = string.sub(input, math.max(0, position - 10), position - 2)
    last_newline_position = string.find(pre_error_content, "\n[^\n]*$")
    if last_newline_position then
        last_newline_position = last_newline_position + 1
    else
        last_newline_position = 0
    end
    local _, error_line = pre_error_content:gsub('\n', "")
    error_line = error_line + 1
    io.stderr:write('syntax error in line ' .. error_line .. ' position ' .. position - last_newline_position .. '\n')
    if position == 0 then
        limit_position = position
    else
        limit_position = position + 11
    end

    io.stderr:write(pre_error_content,
            '|', string.sub(input, position - 1, position - 1), '|',
            string.sub(input, position, limit_position))
end

function parser.parse(pattern, input)
    local result = lpeg.match(pattern, input)
    if not result then
        syntaxError(input, parser.max_space_position)
    end
    return result
end

return parser
