---
--- Generated by Luanalysis
--- Created by rodelbianco.
--- DateTime: 4/1/23 1:10 PM
---

local runtime = { _version = "0.0.1" }

local helpers = require('./utils/helpers')

local function bool_as_number(value)

    if type(value) == 'number' then
        if value > 0 then
            return 1
        else
            return 0
        end
    end
    if value == true then
        return 1
    else
        return 0
    end
end

local function number_as_bool(value)
    if type(value) == boolean then
        return value
    end
    if value > 0 then
        return true
    else
        return false
    end
end

function load_var(blocks, current_block, id)
    level = current_block
    while blocks[level][id] == nil and level > 1 do
        level = level - 1
    end
    return blocks[level][id]
end

function store_var(blocks, current_block, id, value, max_depth)
    level = current_block
    local max_depth = max_depth or 1
    while blocks[level][id] == nil and level > max_depth do
        level = level - 1
    end
    if level > 1 and level < current_block then
        blocks[level][id] = value
    else
        blocks[current_block][id] = value
    end
end

function runtime.run(exec_plan, global_mem, mem, stack, injection_plan)
    local exec_plan = helpers.deepcopy(exec_plan)
    local stack = helpers.deepcopy(stack)
    local blocks = {}

    local counter = 1
    local top = #stack

    blocks[1] = global_mem or {}
    blocks[2] = mem or {}
    local current_block = #blocks

    while counter <= #exec_plan do
        --[[
        io.write('--> ')
        for i = 1, top do io.write(stack[i], ' ') end
        io.write('\n', exec_plan[counter], '\n')
        --]]
        if exec_plan[counter] == 'ret' then
            blocks[current_block] = nil
            current_block = current_block - 1
            break ;
        elseif exec_plan[counter] == 'open_block' then
            blocks[current_block + 1] = {}
            current_block = current_block + 1
            if injection_plan then
                runtime.run(injection_plan, global_mem, blocks[current_block], stack, nil)
                top = #stack
            end
        elseif exec_plan[counter] == 'close_block' then
            blocks[current_block] = nil
            current_block = current_block - 1
        elseif exec_plan[counter] == 'pushdef' then
            top = top + 1
            stack[top] = nil
        elseif exec_plan[counter] == 'prt' then
            print('console.out:')
            if helpers.istable(stack[top]) and stack[top].size ~= nil then
                for i, value in ipairs(stack[top]) do
                    print('index: ' .. i .. '->' .. helpers.as_string(value))
                end
            else
                print(stack[top])
            end
        elseif exec_plan[counter] == 'push' then
            counter = counter + 1
            top = top + 1
            stack[top] = exec_plan[counter]
        elseif exec_plan[counter] == 'load' then
            counter = counter + 1
            local id = exec_plan[counter]
            top = top + 1
            stack[top] = load_var(blocks, current_block, id)
        elseif exec_plan[counter] == 'global_load' then
            counter = counter + 1
            local id = exec_plan[counter]
            top = top + 1
            stack[top] = blocks[1][id]

        elseif exec_plan[counter] == 'store' then
            counter = counter + 1
            local id = exec_plan[counter]
            store_var(blocks, current_block, id, stack[top], nil)
            top = top - 1
        elseif exec_plan[counter] == 'local_store' then
            counter = counter + 1
            local id = exec_plan[counter]
            store_var(blocks, current_block, id, stack[top], current_block)
            top = top - 1
        elseif exec_plan[counter] == 'global_store' then
            counter = counter + 1
            local id = exec_plan[counter]
            blocks[1][id] = stack[top]
            top = top - 1

        elseif exec_plan[counter] == 'newarray' then
            local seed = stack[top - 1]
            local size = stack[top]
            stack[top] = { size = size }

            local new_array = stack[top]
            for index = 1, size do
                new_array[index] = helpers.deepcopy(seed)
            end

            stack[top - 1] = new_array
            top = top - 1
        elseif exec_plan[counter] == 'getarray' then
            local array = stack[top - 1]
            local index = stack[top]
            if index > array.size then
                error('index out of bound -> (' .. helpers.as_string(array) .. ')' .. ' index: ' .. helpers.as_string(index))
            end
            stack[top - 1] = array[index]
            top = top - 1
        elseif exec_plan[counter] == 'setarray' then
            local array = stack[top - 2]
            local index = stack[top - 1]
            local value = stack[top]
            array[index] = value
            top = top - 3
        elseif exec_plan[counter] == 'jump' then
            counter = counter + 1
            counter = counter + exec_plan[counter]
        elseif exec_plan[counter] == 'jumpz' then
            counter = counter + 1
            if stack[top] == 0 or stack[top] == nil then
                counter = counter + exec_plan[counter]
            end
            top = top - 1
        elseif exec_plan[counter] == 'jumpo' then
            counter = counter + 1
            if stack[top] == 1 then
                counter = counter + exec_plan[counter]
            end
            top = top - 1
        elseif exec_plan[counter] == 'jumpzp' then
            counter = counter + 1
            if stack[top] == 0 or stack[top] == nil then
                counter = counter + exec_plan[counter]
            else
                top = top - 1
            end
        elseif exec_plan[counter] == 'jumpnzp' then
            counter = counter + 1
            if stack[top] == 1 then
                counter = counter + exec_plan[counter]
            else
                top = top - 1
            end
        elseif exec_plan[counter] == 'call' then
            local injection_plan = {}
            counter = counter + 1
            top = #stack

            if exec_plan[counter] == 'args' then
                counter = counter + 1
                local args = exec_plan[counter]
                while args > 0 do
                    counter = counter + 1
                    if exec_plan[counter] == 'inject' then
                        injection_plan[#injection_plan + 1] = 'store'
                        counter = counter + 1
                        injection_plan[#injection_plan + 1] = exec_plan[counter]
                        args = args - 1
                    elseif exec_plan[counter] == 'load' then
                        injection_plan[#injection_plan + 1] = 'push'
                        counter = counter + 1
                        local push_value = helpers.deepcopy(load_var(blocks, current_block, exec_plan[counter]))
                        injection_plan[#injection_plan + 1] = push_value
                    else
                        injection_plan[#injection_plan + 1] = exec_plan[counter]
                    end
                end
                counter = counter + 1
            end

            local function_exec_plan = helpers.deepcopy(exec_plan[counter])
            local function_stack = helpers.deepcopy(stack)

            top = top + 1

            stack[top] = runtime.run(function_exec_plan, global_mem, nil, function_stack, injection_plan)
        elseif exec_plan[counter] == 'pop' then
            counter = counter + 1
            top = top - exec_plan[counter]
        elseif exec_plan[counter] == 'add' then
            stack[top - 1] = stack[top - 1] + stack[top]
            top = top - 1
        elseif exec_plan[counter] == 'sub' then
            stack[top - 1] = stack[top - 1] - stack[top]
            top = top - 1
        elseif exec_plan[counter] == 'mul' then
            stack[top - 1] = stack[top - 1] * stack[top]
            top = top - 1
        elseif exec_plan[counter] == 'div' then
            stack[top - 1] = stack[top - 1] / stack[top]
            top = top - 1
        elseif exec_plan[counter] == 'pow' then
            stack[top - 1] = stack[top - 1] ^ stack[top]
            top = top - 1
        elseif exec_plan[counter] == 'rem' then
            stack[top - 1] = stack[top - 1] % stack[top]
            top = top - 1
        elseif exec_plan[counter] == 'lte' then
            stack[top - 1] = bool_as_number(stack[top - 1] <= stack[top])
            top = top - 1
        elseif exec_plan[counter] == 'gte' then
            stack[top - 1] = bool_as_number(stack[top - 1] >= stack[top])
            top = top - 1
        elseif exec_plan[counter] == 'eq' then
            stack[top - 1] = bool_as_number(stack[top - 1] == stack[top])
            top = top - 1
        elseif exec_plan[counter] == 'dif' then
            stack[top - 1] = bool_as_number(stack[top - 1] ~= stack[top])
            top = top - 1
        elseif exec_plan[counter] == 'lt' then
            stack[top - 1] = bool_as_number(stack[top - 1] < stack[top])
            top = top - 1
        elseif exec_plan[counter] == 'gt' then
            stack[top - 1] = bool_as_number(stack[top - 1] > stack[top])
            top = top - 1
        elseif exec_plan[counter] == 'and' then
            stack[top - 1] = bool_as_number(stack[top - 1] == 1 and stack[top] == 1)
            top = top - 1
        elseif exec_plan[counter] == 'or' then
            stack[top - 1] = bool_as_number(stack[top - 1] == 1 or stack[top] == 1)
            top = top - 1
        elseif exec_plan[counter] == 'uneg' then
            stack[top] = stack[top] * -1
        elseif exec_plan[counter] == 'bneg' then
            if stack[top] == 0 then
                stack[top] = 1
            else
                stack[top] = 0
            end
        else
            error('unknown instruction -> (' .. helpers.as_string(exec_plan[counter]) .. ')' .. '\n' .. helpers.as_string(exec_plan))
        end

        counter = counter + 1
    end
    return helpers.deepcopy(stack[top])
end

return runtime